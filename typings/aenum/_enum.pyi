# ruff: noqa
# sourcery skip
# type: ignore
"""
This type stub file was generated by pyright.
"""

import enum
import sqlite3

from enum import Enum as StdlibEnum
from enum import EnumMeta as StdlibEnumMeta
from enum import Flag as StdlibFlag
from enum import ReprEnum as StdlibReprEnum
from types import DynamicClassAttribute

from ._common import *
from ._constant import NamedConstant
from ._tuple import NamedTuple

__all__ = [
    "CONFORM",
    "EJECT",
    "KEEP",
    "STRICT",
    "AddValue",
    "AddValueEnum",
    "AutoNumberEnum",
    "Enum",
    "EnumDict",
    "EnumMeta",
    "EnumType",
    "Flag",
    "FlagBoundary",
    "IntEnum",
    "IntFlag",
    "LowerStrEnum",
    "MagicValue",
    "MultiValue",
    "MultiValueEnum",
    "NoAlias",
    "NoAliasEnum",
    "OrderedEnum",
    "ReprEnum",
    "SqliteEnum",
    "StrEnum",
    "Unique",
    "UniqueEnum",
    "UpperStrEnum",
    "_reduce_ex_by_name",
    "add_stdlib_integration",
    "auto",
    "bin",
    "bit_count",
    "bits",
    "cls2module",
    "enum",
    "enum_property",
    "export",
    "extend_enum",
    "is_single_bit",
    "no_arg",
    "property",
    "remove_stdlib_integration",
    "show_flag_values",
    "sqlite3",
    "unique",
]
_bltin_bin = ...
stdlib_enums = ...
if hasattr(enum, "version"): ...
else:
    StdlibReprEnum = ...
    stdlib_enums = ...
if StdlibEnum: ...
Unique = ...

def export(
    collection, namespace=...
):  # -> Callable[..., ... | type[NamedConstant] | Any | type[Enum] | type[IntEnum] | type[Flag] | type[IntFlag] | type[StrEnum] | type[ReprEnum]] | type[NamedConstant] | type[Enum] | type[IntEnum] | type[Flag] | type[IntFlag] | type[StrEnum] | type[ReprEnum]:
    """
    export([collection,] namespace) -> Export members to target namespace.

    If collection is not given, act as a decorator.
    """
    ...

def bit_count(num):  # -> int:
    """
    return number of set bits

    Counting bits set, Brian Kernighan's way*

        unsigned int v;          // count the number of bits set in v
        unsigned int c;          // c accumulates the total bits set in v
        for (c = 0; v; c++)
        {   v &= v - 1;  }       //clear the least significant bit set

    This method goes through as many iterations as there are set bits. So if we
    have a 32-bit word with only the high bit set, then it will only go once
    through the loop.

    * The C Programming Language 2nd Ed., Kernighan & Ritchie, 1988.

    This works because each subtraction "borrows" from the lowest 1-bit. For
    example:

          loop pass 1     loop pass 2
          -----------     -----------
               101000          100000
             -      1        -      1
             = 100111        = 011111
             & 101000        & 100000
             = 100000        =      0

    It is an excellent technique for Python, since the size of the integer need
    not be determined beforehand.

    (from https://wiki.python.org/moin/BitManipulation)
    """
    ...

def bin(value, max_bits=..., invert=...):  # -> str:
    """
    Like built-in bin(), except negative values are either represented
    in twos-compliment with the leading bit indicating sign (0=positive, 1=negative),
    or shown as positive with a sign bit of '~'.

    >>> bin(10)
    '0b0 1010'
    >>> bin(~10)  # ~10 is -11
    '0b1 0101'
    >>> bin(~10, invert=True)  # ~10 is -11
    '0b~ 1010'
    """
    ...

def show_flag_values(value):  # -> list[Any]:
    ...

base = ...

def info(enum):  # -> None:
    """
    show details about given enum/flag
    """
    ...

class property(base):
    """
    This is a descriptor, used to define attributes that act differently
    when accessed through an enum member and through an enum class.
    Instance access is the same as property(), but access to an attribute
    through the enum class will look in the class' _member_map_.
    """

    member = ...
    def __init__(self, fget=..., fset=..., fdel=..., doc=...) -> None: ...
    def getter(self, fget):  # -> Self:
        ...
    def setter(self, fset):  # -> Self:
        ...
    def deleter(self, fdel):  # -> Self:
        ...
    def __repr__(self):  # -> LiteralString:
        ...
    def __get__(self, instance, ownerclass=...): ...
    def __set__(self, instance, value):  # -> None:
        ...
    def __delete__(self, instance):  # -> None:
        ...
    def __set_name__(self, ownerclass, name):  # -> None:
        ...

_RouteClassAttributeToGetattr = property
if DynamicClassAttribute is None:
    DynamicClassAttribute = ...
enum_property = property

class SentinelType(type):
    def __repr__(cls):  # -> str:
        ...

Sentinel = ...

def bits(num):  # -> str | LiteralString:
    ...
def bit_count(num):  # -> int:
    """
    return number of set bits

    Counting bits set, Brian Kernighan's way*

        unsigned int v;          // count the number of bits set in v
        unsigned int c;          // c accumulates the total bits set in v
        for (c = 0; v; c++)
        {   v &= v - 1;  }       //clear the least significant bit set

    This method goes through as many iterations as there are set bits. So if we
    have a 32-bit word with only the high bit set, then it will only go once
    through the loop.

    * The C Programming Language 2nd Ed., Kernighan & Ritchie, 1988.

    This works because each subtraction "borrows" from the lowest 1-bit. For example:

          loop pass 1     loop pass 2
          -----------     -----------
               101000          100000
             -      1        -      1
             = 100111        = 011111
             & 101000        & 100000
             = 100000        =      0

    It is an excellent technique for Python, since the size of the integer need not
    be determined beforehand.
    """
    ...

def bit_len(num):  # -> int:
    ...
def is_single_bit(num):
    """
    True if only one bit set in num (should be an int)
    """
    ...

def enumsort(things):  # -> list[Any]:
    """
    sorts things by value if all same type; otherwise by name
    """
    ...
@export(globals())
class EnumConstants(NamedConstant):
    AddValue = ...
    MagicValue = ...
    MultiValue = ...
    NoAlias = ...
    Unique = ...
    def __repr__(self): ...

KEEP = ...

class enum:
    """
    Helper class to track args, kwds.
    """
    def __init__(self, *args, **kwds) -> None: ...
    @bltin_property
    def args(self):  # -> tuple[Any, ...]:
        ...
    @bltin_property
    def kwds(self):  # -> dict[str, Any]:
        ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(self):  # -> str:
        ...

_auto_null = ...

class auto(enum):
    """
    Instances are replaced with an appropriate value in Enum class suites.
    """

    enum_member = _auto_null
    _value = ...
    _operations = ...
    def __and__(self, other):  # -> Self:
        ...
    def __rand__(self, other):  # -> Self:
        ...
    def __invert__(self):  # -> Self:
        ...
    def __or__(self, other):  # -> Self:
        ...
    def __ror__(self, other):  # -> Self:
        ...
    def __xor__(self, other):  # -> Self:
        ...
    def __rxor__(self, other):  # -> Self:
        ...
    def __abs__(self):  # -> Self:
        ...
    def __add__(self, other):  # -> Self:
        ...
    def __radd__(self, other):  # -> Self:
        ...
    def __neg__(self):  # -> Self:
        ...
    def __pos__(self):  # -> Self:
        ...

    if PY2:
        def __div__(self, other):  # -> Self:
            ...

    def __rdiv__(self, other):  # -> Self:
        ...
    def __floordiv__(self, other):  # -> Self:
        ...
    def __rfloordiv__(self, other):  # -> Self:
        ...
    def __truediv__(self, other):  # -> Self:
        ...
    def __rtruediv__(self, other):  # -> Self:
        ...
    def __lshift__(self, other):  # -> Self:
        ...
    def __rlshift__(self, other):  # -> Self:
        ...
    def __rshift__(self, other):  # -> Self:
        ...
    def __rrshift__(self, other):  # -> Self:
        ...
    def __mod__(self, other):  # -> Self:
        ...
    def __rmod__(self, other):  # -> Self:
        ...
    def __mul__(self, other):  # -> Self:
        ...
    def __rmul__(self, other):  # -> Self:
        ...
    def __pow__(self, other):  # -> Self:
        ...
    def __rpow__(self, other):  # -> Self:
        ...
    def __sub__(self, other):  # -> Self:
        ...
    def __rsub__(self, other):  # -> Self:
        ...
    def __repr__(self):  # -> str:
        ...
    @bltin_property
    def value(self):  # -> type[no_value]:
        ...
    @value.setter
    def value(self, value):  # -> None:
        ...

class _EnumArgSpec(NamedTuple):
    args = ...
    varargs = ...
    keywords = ...
    defaults = ...
    required = ...
    def __new__(cls, _new_func): ...

class _proto_member:
    """
    intermediate step for enum members between class execution and final creation
    """
    def __init__(self, value) -> None: ...
    def __set_name__(self, enum_class, member_name):
        """
        convert each quasi-member into an instance of the new enum class
        """
        ...

class EnumDict(dict):
    """Track enum member order and ensure member names are not reused.

    EnumType will use the names found in self._member_names as the
    enumeration member names.
    """
    def __init__(
        self, cls_name, settings, start, constructor_init, constructor_start, constructor_boundary
    ) -> None: ...
    def __getitem__(self, key):  # -> type[enum]:
        ...
    def __setitem__(self, key, value):
        """Changes anything not sundured, dundered, nor a descriptor.

        If an enum member name is used twice, an error is raised; duplicate
        values are not checked for.

        Single underscore (sunder) names are reserved.
        """
        ...

no_arg = ...

class EnumType(type):
    """Metaclass for Enum"""
    @classmethod
    def __prepare__(
        metacls, cls, bases, init=..., start=..., settings=..., boundary=..., **kwds
    ): ...
    def __init__(cls, *args, **kwds) -> None: ...
    def __new__(
        metacls, cls, bases, clsdict, init=..., start=..., settings=..., boundary=..., **kwds
    ): ...
    def __bool__(cls):  # -> Literal[True]:
        """
        classes/types should always be True.
        """
        ...

    def __call__(
        cls, value=..., names=..., module=..., qualname=..., type=..., start=..., boundary=...
    ):
        """Either returns an existing member, or creates a new enum class.

        This method is used both when an enum class is given a value to match
        to an enumeration member (i.e. Color(3)) and for the functional API
        (i.e. Color = Enum('Color', names='red green blue')).

        When used for the functional API: `module`, if set, will be stored in
        the new class' __module__ attribute; `type`, if set, will be mixed in
        as the first base class.

        Note: if `module` is not set this routine will attempt to discover the
        calling module by walking the frame stack; if this is unsuccessful
        the resulting class will not be pickleable.
        """
        ...

    def __contains__(cls, value):  # -> bool:
        """Return True if `value` is in `cls`.

        `value` is in `cls` if:
        1) `value` is a member of `cls`, or
        2) `value` is the value of one of the `cls`'s members.
        """
        ...

    def __delattr__(cls, attr):  # -> None:
        ...
    def __dir__(cls):  # -> list[Any] | list[str | Any]:
        ...
    @bltin_property
    def __members__(cls):
        """Returns a mapping of member name->value.

        This mapping lists all enum members, including aliases. Note that this
        is a copy of the internal mapping.
        """
        ...

    def __getitem__(cls, name):  # -> <subclass of EnumType* and Flag> | UnionType:
        ...
    def __iter__(cls):  # -> Generator[Any, None, None]:
        ...
    def __reversed__(cls):  # -> Generator[Any, None, None]:
        ...
    def __len__(cls):  # -> int:
        ...

    __nonzero__ = ...
    def __repr__(cls):  # -> str:
        ...
    def __setattr__(cls, name, value):  # -> None:
        """Block attempts to reassign Enum members/constants.

        A simple assignment to the class namespace only changes one of the
        several possible ways to get an Enum member from the Enum class,
        resulting in an inconsistent Enumeration.
        """
        ...

if StdlibEnumMeta:
    class EnumType(EnumType, StdlibEnumMeta): ...

EnumMeta = EnumType
enum_dict = ...

@enum_dict
@classmethod
def __signature__(cls):  # -> LiteralString | Literal['(*values)']:
    ...
@enum_dict
def __init__(self, *args, **kwds) -> None: ...
@enum_dict
def __new__(cls, value): ...
@enum_dict
@classmethod
def __init_subclass__(cls, **kwds):  # -> None:
    ...
@enum_dict
def __repr__(self):  # -> LiteralString:
    ...
@enum_dict
def __str__(self) -> str: ...

if PY3:
    @enum_dict
    def __dir__(self):  # -> list[str]:
        """
        Returns all public methods
        """
        ...

@enum_dict
def __format__(self, format_spec):  # -> str:
    ...
@enum_dict
def __hash__(self) -> int: ...
@enum_dict
def __reduce_ex__(self, proto):  # -> tuple[Any, tuple[Any]]:
    ...
@enum_dict
def __le__(self, other) -> bool: ...
@enum_dict
def __lt__(self, other) -> bool: ...
@enum_dict
def __ge__(self, other) -> bool: ...
@enum_dict
def __gt__(self, other) -> bool: ...
@enum_dict
def __eq__(self, other) -> bool: ...
@enum_dict
def __ne__(self, other) -> bool: ...
@enum_dict
@property
def name(self): ...
@enum_dict
@property
def value(self): ...
@enum_dict
@property
def values(self): ...

_enum_base = ...
Enum = ...

def pickle_by_global_name(self, proto): ...

_reduce_ex_by_name = ...

def pickle_by_enum_name(self, proto):  # -> tuple[Callable[..., Any], tuple[Any, Any]]:
    ...

if StdlibReprEnum:
    _repr_bases = ...
else:
    _repr_bases = ...
ReprEnum = ...

class IntEnum(int, ReprEnum):
    """
    Enum where members are also (and must be) ints
    """

    ...

class StrEnum(str, ReprEnum):
    """
    Enum where members are also (and must already be) strings

    default value is member name, lower-cased
    """
    def __new__(cls, *values, **kwds):  # -> Self:
        ...

    __str__ = ...

class LowerStrEnum(StrEnum):
    """
    Enum where members are also (and must already be) lower-case strings

    default value is member name, lower-cased
    """
    def __new__(cls, value, *args, **kwds): ...

class UpperStrEnum(StrEnum):
    """
    Enum where members are also (and must already be) upper-case strings

    default value is member name, upper-cased
    """
    def __new__(cls, value, *args, **kwds): ...

if PY3:
    class AutoEnum(Enum):
        """
        automatically use _generate_next_value_ when values are missing (Python 3 only)
        """

        _settings_ = ...

class AutoNumberEnum(Enum):
    """
    Automatically assign increasing values to members.

    Py3: numbers match creation order
    Py2: numbers are assigned alphabetically by member name
         (unless `_order_` is specified)
    """
    def __new__(cls, *args, **kwds):  # -> Self:
        ...

class AddValueEnum(Enum):
    _settings_ = ...

class MultiValueEnum(Enum):
    """
    Multiple values can map to each member.
    """

    _settings_ = ...

class NoAliasEnum(Enum):
    """
    Duplicate value members are distinct, but cannot be looked up by value.
    """

    _settings_ = ...

class OrderedEnum(Enum):
    """
    Add ordering based on values of Enum members.
    """
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...

if sqlite3:
    class SqliteEnum(Enum):
        def __conform__(self, protocol):  # -> None:
            ...

class UniqueEnum(Enum):
    """
    Ensure no duplicate values exist.
    """

    _settings_ = ...

def convert(enum, name, module, filter, source=...):  # -> None:
    """
    Create a new Enum subclass that replaces a collection of global constants

    enum: Enum, IntEnum, ...
    name: name of new Enum
    module: name of module (__name__ in global context)
    filter: function that returns True if name should be converted to Enum member
    source: namespace to check (defaults to 'module')
    """
    ...

def extend_enum(
    enumeration: type[EnumType], name: str, *args: Any, **kwds: dict[str, Any]
) -> type[EnumType]:
    """
    Add a new member to an existing Enum.
    """
    ...

def unique(enumeration):
    """
    Class decorator that ensures only unique members exist in an enumeration.
    """
    ...

if StdlibFlag:
    _flag_bases = ...
else:
    _flag_bases = ...
flag_dict = ...

@flag_dict
def __contains__(self, other):  # -> Literal[False]:
    """
    Returns True if self has at least the same flags set as other.
    """
    ...

@flag_dict
def __iter__(self):  # -> Generator[Any, Any, None]:
    """
    Returns flags in definition order.
    """
    ...

@flag_dict
def __len__(self):  # -> int:
    ...
@flag_dict
def __repr__(self):  # -> LiteralString:
    ...
@flag_dict
def __str__(self) -> str: ...

if PY2:
    @flag_dict
    def __nonzero__(self):  # -> bool:
        ...

else:
    @flag_dict
    def __bool__(self):  # -> bool:
        ...

@flag_dict
def __or__(self, other):  # -> _NotImplementedType:
    ...
@flag_dict
def __and__(self, other):  # -> _NotImplementedType:
    ...
@flag_dict
def __xor__(self, other):  # -> _NotImplementedType:
    ...
@flag_dict
def __invert__(self): ...

Flag = ...

class IntFlag(int, ReprEnum, Flag):
    "Support for integer-based Flags"

    _boundary_ = ...
    def __contains__(self, other):  # -> Literal[False]:
        """
        Returns True if self has at least the same flags set as other.
        """
        ...

def global_enum_repr(self):  # -> LiteralString:
    """
    use module.enum_name instead of class.enum_name

    the module is the last module in case of a multi-module name
    """
    ...

def global_flag_repr(self):  # -> LiteralString:
    """
    use module.flag_name instead of class.flag_name

    the module is the last module in case of a multi-module name
    """
    ...

def global_str(self):  # -> LiteralString:
    """
    use enum_name instead of class.enum_name
    """
    ...

def global_enum(cls, update_str=...):
    """
    decorator that makes the repr() of an enum member reference its module
    instead of its class; also exports all members to the enum's module's
    global namespace
    """
    ...

if StdlibEnumMeta:
    def __subclasscheck__(cls, subclass):  # -> bool:
        """
        Override for issubclass(subclass, cls).
        """
        ...

    def __instancecheck__(cls, instance):  # -> None:
        ...

def add_stdlib_integration():  # -> None:
    ...
def remove_stdlib_integration():  # -> None:
    """
    Remove the __instancecheck__ and __subclasscheck__ overrides from the stdlib Enum.

    Those overrides are in place so that code detecting stdlib enums will also detect
    aenum enums.  If a buggy __getattribute__, __instancecheck__, or __subclasscheck__
    is defined on a custom EnumMeta then RecursionErrors can result; using this
    function after importing aenum will solve that problem, but the better solution is
    to fix the buggy method.
    """
    ...

class cls2module:
    def __init__(self, cls, *args) -> None: ...
    def register(self):  # -> None:
        ...
