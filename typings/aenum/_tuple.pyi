# ruff: noqa
# sourcery: skip
# type: ignore
"""This type stub file was generated by pyright."""

from ._common import *
from ._constant import NamedConstant

__all__ = ["TupleSize", "NamedTuple"]

class NamedTupleDict(OrderedDict):
    """Track field order and ensure field names are not reused.

    NamedTupleMeta will use the names found in self._field_names to translate
    to indices.
    """
    def __init__(self, *args, **kwds) -> None: ...
    def __setitem__(self, key, value):  # -> None:
        """Records anything not dundered or not a descriptor.

        If a field name is used twice, an error is raised.

        Single underscore (sunder) names are reserved.
        """
        ...

class _TupleAttributeAtIndex:
    def __init__(self, name, index, doc, default) -> None: ...
    def __get__(self, instance, owner):  # -> Self:
        ...
    def __repr__(self):  # -> str:
        ...

class TupleSize(NamedConstant):
    fixed = ...
    minimum = ...
    variable = ...

class NamedTupleMeta(type):
    "Metaclass for NamedTuple"
    @classmethod
    def __prepare__(metacls, cls, bases, size=..., **kwds):  # -> NamedTupleDict:
        ...
    def __init__(cls, *args, **kwds) -> None: ...
    def __new__(metacls, cls, bases, clsdict, size=..., **kwds): ...
    def __add__(cls, other):  # -> _NotImplementedType | type[__class_NamedTupleMeta]:
        "A new NamedTuple is created by concatenating the _fields_ and adjusting the descriptors"
        ...

    def __call__(cls, *args, **kwds):
        """Creates a new NamedTuple class or an instance of a NamedTuple subclass.

        NamedTuple should have args of (class_name, names, module)

            `names` can be:

                * A string containing member names, separated either with spaces or
                  commas.  Values are auto-numbered from 1.
                * An iterable of member names.  Values are auto-numbered from 1.
                * An iterable of (member name, value) pairs.
                * A mapping of member name -> value.

                `module`, if set, will be stored in the new class' __module__ attribute;

                Note: if `module` is not set this routine will attempt to discover the
                calling module by walking the frame stack; if this is unsuccessful
                the resulting class will not be pickleable.

        subclass should have whatever arguments and/or keywords will be used to create an
        instance of the subclass
        """
        ...

    @bltin_property
    def __fields__(cls):  # -> list[Any]:
        ...

    _fields = ...
    @bltin_property
    def __aliases__(cls):  # -> list[Any]:
        ...
    def __repr__(cls):  # -> str:
        ...

namedtuple_dict = ...

@namedtuple_dict
def __new__(cls, *args, **kwds): ...
@namedtuple_dict
def __getitem__(self, index):  # -> Any:
    ...
@namedtuple_dict
def __reduce_ex__(self, proto):  # -> tuple[Any, tuple[Any, ...]]:
    ...
@namedtuple_dict
def __repr__(self):  # -> LiteralString | str:
    ...
@namedtuple_dict
def __str__(self) -> str: ...
@namedtuple_dict
@bltin_property
def __aliases__(self):  # -> list[Any]:
    ...

NamedTuple = ...
