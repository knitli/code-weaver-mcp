# ruff: noqa
# sourcery: skip
# type: ignore
"""This type stub file was generated by pyright."""

import unittest

from datetime import date, timedelta
from enum import CONTINUOUS, NAMED_FLAGS, UNIQUE, global_enum, verify

import aenum as enum

from aenum import (
    CONFORM,
    EJECT,
    KEEP,
    STRICT,
    Enum,
    Flag,
    IntEnum,
    IntFlag,
    ReprEnum,
    StrEnum,
    member,
    nonmember,
    unique,
)

python_version = ...
MODULE = ...
SHORT_MODULE = ...

class AlwaysEqual:
    def __eq__(self, other) -> bool: ...

ALWAYS_EQ = ...

class Stooges(Enum):
    LARRY = ...
    CURLY = ...
    MOE = ...

class IntStooges(int, Enum):
    LARRY = ...
    CURLY = ...
    MOE = ...

class FloatStooges(float, Enum):
    LARRY = ...
    CURLY = ...
    MOE = ...

class FlagStooges(Flag):
    LARRY = ...
    CURLY = ...
    MOE = ...

class FlagStoogesWithZero(Flag):
    NOFLAG = ...
    LARRY = ...
    CURLY = ...
    MOE = ...

class IntFlagStooges(IntFlag):
    LARRY = ...
    CURLY = ...
    MOE = ...

class IntFlagStoogesWithZero(IntFlag):
    NOFLAG = ...
    LARRY = ...
    CURLY = ...
    MOE = ...

class Name(StrEnum):
    BDFL = ...
    FLUFL = ...

Question = ...
Answer = ...
Theory = ...

class Fruit(Enum):
    TOMATO = ...
    BANANA = ...
    CHERRY = ...

def test_pickle_dump_load(assertion, source, target=...):  # -> None:
    ...
def test_pickle_exception(assertion, exception, obj):  # -> None:
    ...

class TestHelpers(unittest.TestCase):
    sunder_names = ...
    dunder_names = ...
    private_names = ...
    private_and_sunder_names = ...
    random_names = ...
    def test_is_descriptor(self):  # -> None:
        class foo: ...

    def test_sunder(self):  # -> None:
        ...
    def test_dunder(self):  # -> None:
        ...
    def test_is_private(self):  # -> None:
        ...
    def test_iter_bits_lsb(self):  # -> None:
        ...

class classproperty:
    def __init__(self, fget=..., fset=..., fdel=..., doc=...) -> None: ...
    def __get__(self, instance, ownerclass): ...

@global_enum
class HeadlightsK(IntFlag, boundary=enum.KEEP):
    OFF_K = ...
    LOW_BEAM_K = ...
    HIGH_BEAM_K = ...
    FOG_K = ...

@global_enum
class HeadlightsC(IntFlag, boundary=enum.CONFORM):
    OFF_C = ...
    LOW_BEAM_C = ...
    HIGH_BEAM_C = ...
    FOG_C = ...

@global_enum
class NoName(Flag):
    ONE = ...
    TWO = ...

class _EnumTests:
    """
    Test for behavior that is the same across the different types of enumerations.
    """

    values = ...
    def setUp(self):  # -> None:
        class BaseEnum(self.enum_type): ...
        class MainEnum(BaseEnum): ...
        class NewStrEnum(self.enum_type): ...
        class NewFormatEnum(self.enum_type): ...
        class NewStrFormatEnum(self.enum_type): ...
        class NewBaseEnum(self.enum_type): ...
        class NewSubEnum(NewBaseEnum): ...

    def assertFormatIsValue(self, spec, member):  # -> None:
        ...
    def assertFormatIsStr(self, spec, member):  # -> None:
        ...
    def test_attribute_deletion(self):  # -> None:
        class Season(self.enum_type): ...

    def test_basics(self):  # -> None:
        ...
    def test_bool_is_true(self):  # -> None:
        class Empty(self.enum_type): ...

    def test_changing_member_fails(self):  # -> None:
        ...
    def test_contains_tf(self):  # -> None:
        class OtherEnum(Enum): ...

    def test_contains_same_name_diff_enum_diff_values(self):  # -> None:
        class OtherEnum(Enum): ...

    def test_dir_on_class(self):  # -> None:
        ...
    def test_dir_on_item(self):  # -> None:
        ...
    def test_dir_with_added_behavior(self):  # -> None:
        class Test(self.enum_type): ...

    def test_dir_on_sub_with_behavior_on_super(self):  # -> None:
        class SuperEnum(self.enum_type): ...
        class SubEnum(SuperEnum): ...

    def test_dir_on_sub_with_behavior_including_instance_dict_on_super(self):  # -> None:
        class SuperEnum(self.enum_type): ...
        class SubEnum(SuperEnum): ...

    def test_enum_in_enum_out(self):  # -> None:
        ...
    def test_hash(self):  # -> None:
        ...
    def test_invalid_names(self):  # -> None:
        ...
    def test_object_str_override(self):  # -> None:
        "check that setting __str__ to object's is not reset to Enum's"
        class Generic(self.enum_type): ...

    def test_overridden_str(self):  # -> None:
        ...
    def test_overridden_str_format(self):  # -> None:
        ...
    def test_overridden_str_format_inherited(self):  # -> None:
        ...
    def test_programmatic_function_string(self):  # -> None:
        ...
    def test_programmatic_function_string_list(self):  # -> None:
        ...
    def test_programmatic_function_iterable(self):  # -> None:
        ...
    def test_programmatic_function_from_dict(self):  # -> None:
        ...
    def test_repr(self):  # -> None:
        ...
    def test_repr_override(self):  # -> None:
        class Generic(self.enum_type): ...

    def test_inherited_repr(self):  # -> None:
        class MyEnum(self.enum_type): ...
        class MySubEnum(MyEnum): ...

    def test_reversed_iteration_order(self):  # -> None:
        ...

class _PlainOutputTests:
    def test_str(self):  # -> None:
        ...
    def test_format(self):  # -> None:
        ...
    def test_overridden_format(self):  # -> None:
        ...
    def test_format_specs(self):  # -> None:
        ...

class _MixedOutputTests:
    def test_str(self):  # -> None:
        ...
    def test_format(self):  # -> None:
        ...
    def test_overridden_format(self):  # -> None:
        ...
    def test_format_specs(self):  # -> None:
        ...

class _MinimalOutputTests:
    def test_str(self):  # -> None:
        ...
    def test_format(self):  # -> None:
        ...
    def test_overridden_format(self):  # -> None:
        ...
    def test_format_specs(self):  # -> None:
        ...
    def test_copy(self):  # -> None:
        ...

class _FlagTests:
    def test_default_missing_with_wrong_type_value(self):  # -> None:
        ...

class TestPlainEnum(_EnumTests, _PlainOutputTests, unittest.TestCase):
    enum_type = Enum

class TestPlainFlag(_EnumTests, _PlainOutputTests, _FlagTests, unittest.TestCase):
    enum_type = Flag

class TestIntEnum(_EnumTests, _MinimalOutputTests, unittest.TestCase):
    enum_type = IntEnum

class TestStrEnum(_EnumTests, _MinimalOutputTests, unittest.TestCase):
    enum_type = StrEnum

class TestIntFlag(_EnumTests, _MinimalOutputTests, _FlagTests, unittest.TestCase):
    enum_type = IntFlag

class TestMixedInt(_EnumTests, _MixedOutputTests, unittest.TestCase):
    class enum_type(int, Enum): ...

class TestMixedStr(_EnumTests, _MixedOutputTests, unittest.TestCase):
    class enum_type(str, Enum): ...

class TestMixedIntFlag(_EnumTests, _MixedOutputTests, _FlagTests, unittest.TestCase):
    class enum_type(int, Flag): ...

class TestMixedDate(_EnumTests, _MixedOutputTests, unittest.TestCase):
    values = ...
    source_values = ...
    class enum_type(date, Enum): ...

class TestMinimalDate(_EnumTests, _MinimalOutputTests, unittest.TestCase):
    values = ...
    source_values = ...
    class enum_type(date, ReprEnum): ...

class TestMixedFloat(_EnumTests, _MixedOutputTests, unittest.TestCase):
    values = ...
    class enum_type(float, Enum): ...

class TestMinimalFloat(_EnumTests, _MinimalOutputTests, unittest.TestCase):
    values = ...
    class enum_type(float, ReprEnum): ...

class TestSpecial(unittest.TestCase):
    """
    various operations that are not attributable to every possible enum
    """
    def setUp(self):  # -> None:
        class Season(Enum): ...
        class Grades(IntEnum): ...
        class Directional(str, Enum): ...
        class Holiday(date, Enum): ...

    def test_bool(self):  # -> None:
        class Logic(Enum): ...
        class RealLogic(Enum): ...
        class IntLogic(int, Enum): ...

    def test_comparisons(self):  # -> None:
        class Part(Enum): ...

    @unittest.skip("to-do list")
    def test_dir_with_custom_dunders(self):  # -> None:
        class PlainEnum(Enum): ...
        class MyEnum(Enum): ...

    def test_duplicate_name_error(self):  # -> None:
        ...
    def test_enum_function_with_qualname(self):  # -> None:
        ...
    def test_enum_of_types(self):  # -> None:
        """Support using Enum to refer to types deliberately."""
        class MyTypes(Enum): ...
        class Foo: ...
        class Bar: ...
        class MyTypes2(Enum): ...
        class SpamEnumNotInner: ...
        class SpamEnum(Enum): ...

    def test_enum_of_generic_aliases(self):  # -> None:
        class E(Enum): ...

    @unittest.skipIf(python_version >= (3, 13), "inner classes are not members")
    def test_nested_classes_in_enum_are_members(self):  # -> None:
        """
        Check for warnings pre-3.13
        """
        ...

    @unittest.skipIf(python_version < (3, 13), "inner classes are still members")
    def test_nested_classes_in_enum_are_not_members(self):  # -> None:
        """Support locally-defined nested classes."""
        class Outer(Enum):
            class Inner(Enum): ...

    def test_nested_classes_in_enum_with_nonmember(self):  # -> None:
        class Outer(Enum):
            @nonmember
            class Inner(Enum): ...

    def test_enum_of_types_with_nonmember(self):  # -> None:
        """Support using Enum to refer to types deliberately."""
        class MyTypes(Enum): ...
        class Foo: ...
        class Bar: ...
        class MyTypes2(Enum): ...
        class SpamEnumIsInner: ...
        class SpamEnum(Enum): ...

    def test_nested_classes_in_enum_with_member(self):  # -> None:
        """Support locally-defined nested classes."""
        class Outer(Enum):
            @member
            class Inner(Enum): ...

    def test_enum_with_value_name(self):  # -> None:
        class Huh(Enum): ...

    def test_contains_name_and_value_overlap(self):  # -> None:
        class IntEnum1(IntEnum): ...
        class IntEnum2(IntEnum): ...
        class IntEnum3(IntEnum): ...
        class IntEnum4(IntEnum): ...

    def test_contains_different_types_same_members(self):  # -> None:
        class IntEnum1(IntEnum): ...
        class IntFlag1(IntFlag): ...

    def test_inherited_data_type(self):  # -> None:
        class HexInt(int): ...
        class MyEnum(HexInt, enum.Enum): ...
        class SillyInt(HexInt): ...
        class MyOtherEnum(SillyInt, enum.Enum): ...
        class UnBrokenInt(int): ...
        class MyUnBrokenEnum(UnBrokenInt, Enum): ...

    def test_floatenum_fromhex(self):  # -> None:
        ...
    def test_programmatic_function_type(self):  # -> None:
        ...
    def test_programmatic_function_string_with_start(self):  # -> None:
        ...
    def test_programmatic_function_type_with_start(self):  # -> None:
        ...
    def test_programmatic_function_string_list_with_start(self):  # -> None:
        ...
    def test_programmatic_function_type_from_subclass(self):  # -> None:
        ...
    def test_programmatic_function_type_from_subclass_with_start(self):  # -> None:
        ...
    def test_programmatic_function_is_value_call(self):  # -> None:
        class TwoPart(Enum): ...
        class ThreePart(Enum): ...

    def test_intenum_from_bytes(self):  # -> None:
        ...
    def test_reserved_sunder_error(self):  # -> None:
        ...
    def test_too_many_data_types(self):  # -> None:
        class MyStr(str): ...
        class MyInt(int): ...

    def test_pickle_enum(self):  # -> None:
        ...
    def test_pickle_int(self):  # -> None:
        ...
    def test_pickle_float(self):  # -> None:
        ...
    def test_pickle_enum_function(self):  # -> None:
        ...
    def test_pickle_enum_function_with_module(self):  # -> None:
        ...
    def test_pickle_nested_class(self):  # -> None:
        class NestedEnum(Enum): ...

    def test_pickle_by_name(self):  # -> None:
        class ReplaceGlobalInt(IntEnum): ...

    def test_pickle_explodes(self):  # -> None:
        ...
    def test_string_enum(self):  # -> None:
        class SkillLevel(str, Enum): ...

    def test_getattr_getitem(self):  # -> None:
        class Period(Enum): ...

    def test_getattr_dunder(self):  # -> None:
        ...
    def test_iteration_order(self):  # -> None:
        class Season(Enum): ...

    def test_subclassing(self):  # -> None:
        ...
    def test_extending(self):  # -> None:
        class Color(Enum): ...

    def test_exclude_methods(self):  # -> None:
        class whatever(Enum): ...

    def test_wrong_inheritance_order(self):  # -> None:
        ...
    def test_intenum_transitivity(self):  # -> None:
        class number(IntEnum): ...
        class numero(IntEnum): ...

    def test_wrong_enum_in_call(self):  # -> None:
        class Monochrome(Enum): ...
        class Gender(Enum): ...

    def test_wrong_enum_in_mixed_call(self):  # -> None:
        class Monochrome(IntEnum): ...
        class Gender(Enum): ...

    def test_mixed_enum_in_call_1(self):  # -> None:
        class Monochrome(IntEnum): ...
        class Gender(IntEnum): ...

    def test_mixed_enum_in_call_2(self):  # -> None:
        class Monochrome(Enum): ...
        class Gender(IntEnum): ...

    def test_flufl_enum(self):  # -> None:
        class Fluflnum(Enum): ...
        class MailManOptions(Fluflnum): ...

    def test_introspection(self):  # -> None:
        class Number(IntEnum): ...
        class String(str, Enum): ...
        class Plain(Enum): ...

    def test_no_such_enum_member(self):  # -> None:
        class Color(Enum): ...

    def test_multiple_mixin_mro(self):  # -> None:
        class auto_enum(type(Enum)): ...
        class AutoNumberedEnum(Enum, metaclass=auto_enum): ...
        class AutoIntEnum(IntEnum, metaclass=auto_enum): ...
        class TestAutoNumber(AutoNumberedEnum): ...
        class TestAutoInt(AutoIntEnum): ...

    def test_subclasses_with_getnewargs(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_subclasses_with_getnewargs_ex(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_subclasses_with_reduce(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_subclasses_with_reduce_ex(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_subclasses_without_direct_pickle_support(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_subclasses_with_direct_pickle_support(self):  # -> None:
        class NamedInt(int): ...
        class NEI(NamedInt, Enum): ...

    def test_tuple_subclass(self):  # -> None:
        class SomeTuple(tuple, Enum): ...

    def test_duplicate_values_give_unique_enum_items(self):  # -> None:
        class AutoNumber(Enum): ...

    def test_inherited_new_from_enhanced_enum(self):  # -> None:
        class AutoNumber(Enum): ...
        class Color(AutoNumber): ...

    def test_inherited_new_from_mixed_enum(self):  # -> None:
        class AutoNumber(IntEnum): ...
        class Color(AutoNumber): ...

    def test_equality(self):  # -> None:
        class OrdinaryEnum(Enum): ...

    def test_ordered_mixin(self):  # -> None:
        class OrderedEnum(Enum): ...
        class Grade(OrderedEnum): ...

    def test_extending2(self):  # -> None:
        class Shade(Enum): ...
        class Color(Shade): ...

    def test_extending3(self):  # -> None:
        class Shade(Enum): ...
        class Color(Shade): ...
        class MoreColor(Color): ...

    def test_subclass_duplicate_name(self):  # -> None:
        class Base(Enum): ...
        class Test(Base): ...

    def test_subclass_duplicate_name_dynamic(self):  # -> None:
        class Base(Enum): ...
        class Test(Base): ...
        class Base2(Enum): ...
        class Test(Base2): ...

    def test_no_duplicates(self):  # -> None:
        class UniqueEnum(Enum): ...
        class Color(UniqueEnum): ...

    def test_init(self):  # -> None:
        class Planet(Enum): ...

    def test_ignore(self):  # -> None:
        class Period(timedelta, Enum):
            """
            different lengths of time
            """

            ...

    def test_nonhash_value(self):  # -> None:
        class AutoNumberInAList(Enum): ...
        class ColorInAList(AutoNumberInAList): ...

    def test_conflicting_types_resolved_in_new(self):  # -> None:
        class LabelledIntEnum(int, Enum): ...
        class LabelledList(LabelledIntEnum): ...

    def test_default_missing_no_chained_exception(self):  # -> None:
        class Color(Enum): ...

    def test_missing_override(self):  # -> None:
        class Color(Enum): ...

    def test_missing_exceptions_reset(self):  # -> None:
        class TestEnum(enum.Enum): ...
        class Class1: ...
        class Class2: ...

    def test_multiple_mixin(self):  # -> None:
        class MaxMixin: ...
        class StrMixin: ...
        class SomeEnum(Enum): ...
        class AnotherEnum(Enum): ...
        class Color(MaxMixin, Enum): ...
        class Color(MaxMixin, StrMixin, Enum): ...
        class Color(StrMixin, MaxMixin, Enum): ...
        class CoolColor(StrMixin, SomeEnum, Enum): ...
        class CoolerColor(StrMixin, AnotherEnum, Enum): ...
        class CoolestColor(StrMixin, SomeEnum, AnotherEnum): ...
        class ConfusedColor(StrMixin, AnotherEnum, SomeEnum): ...
        class ReformedColor(StrMixin, IntEnum, SomeEnum, AnotherEnum): ...

    def test_multiple_inherited_mixin(self):  # -> None:
        @unique
        class Decision1(StrEnum): ...

        class MyEnum(StrEnum): ...

        @unique
        class Decision2(MyEnum): ...

    def test_multiple_mixin_inherited(self):  # -> None:
        class MyInt(int): ...
        class HexMixin: ...
        class MyIntEnum(HexMixin, MyInt, enum.Enum): ...
        class Foo(MyIntEnum): ...
        class Fee(MyIntEnum): ...

    def test_multiple_mixin_with_common_data_type(self):  # -> None:
        class CaseInsensitiveStrEnum(str, Enum): ...
        class LenientStrEnum(str, Enum): ...
        class JobStatus(CaseInsensitiveStrEnum, LenientStrEnum): ...

    def test_empty_globals(self):  # -> None:
        ...
    def test_strenum(self):  # -> None:
        class GoodStrEnum(StrEnum): ...
        class DumbMixin: ...
        class DumbStrEnum(DumbMixin, StrEnum): ...
        class EnumMixin(Enum): ...
        class HelloEnum(EnumMixin, StrEnum): ...
        class GoodbyeMixin: ...
        class GoodbyeEnum(GoodbyeMixin, EnumMixin, StrEnum): ...

    def test_custom_strenum(self):  # -> None:
        class CustomStrEnum(str, Enum): ...
        class OkayEnum(CustomStrEnum): ...
        class DumbMixin: ...
        class DumbStrEnum(DumbMixin, CustomStrEnum): ...
        class EnumMixin(Enum): ...
        class HelloEnum(EnumMixin, CustomStrEnum): ...
        class GoodbyeMixin: ...
        class GoodbyeEnum(GoodbyeMixin, EnumMixin, CustomStrEnum): ...
        class FirstFailedStrEnum(CustomStrEnum): ...
        class SecondFailedStrEnum(CustomStrEnum): ...
        class ThirdFailedStrEnum(CustomStrEnum): ...

    def test_missing_value_error(self):  # -> None:
        ...
    def test_private_variable_is_normal_attribute(self):  # -> None:
        class Private(Enum): ...

    @unittest.skipIf(python_version <= (3, 13), "member.member access currently deprecated")
    def test_exception_for_member_from_member_access(self):  # -> None:
        ...
    @unittest.skipIf(python_version > (3, 13), "member.member access now raises")
    def test_warning_for_member_from_member_access(self):  # -> None:
        ...
    def test_dynamic_members_with_static_methods(self):  # -> None:
        class Foo(Enum): ...

    def test_repr_with_dataclass(self):  # -> None:
        "ensure dataclass-mixin has correct repr()"
        @dataclass(repr=False)
        class Foo: ...

        class Entries(Foo, Enum): ...

        @dataclass
        class CreatureDataMixin: ...

        class Creature(CreatureDataMixin, Enum): ...
        class Huh: ...

        @dataclass(repr=False)
        class CreatureDataMixin(Huh): ...

        class Creature(CreatureDataMixin, Enum): ...

        @dataclass(repr=False)
        class CreatureDataMixin: ...

        class Creature(CreatureDataMixin, Enum): ...

    def test_repr_with_init_data_type_mixin(self):  # -> None:
        class Foo: ...
        class Entries(Foo, Enum): ...

    def test_repr_and_str_with_non_data_type_mixin(self):  # -> None:
        class Foo: ...
        class Entries(Foo, Enum): ...

    def test_value_backup_assign(self):  # -> None:
        class Some(Enum): ...

    def test_custom_flag_bitwise(self):  # -> None:
        class MyIntFlag(int, Flag): ...

    def test_int_flags_copy(self):  # -> None:
        class MyIntFlag(IntFlag): ...

    def test_namedtuple_as_value(self):  # -> None:
        class NTEnum(Enum): ...

class TestOrder(unittest.TestCase):
    "test usage of the `_order_` attribute"
    def test_same_members(self):  # -> None:
        class Color(Enum): ...

    def test_same_members_with_aliases(self):  # -> None:
        class Color(Enum): ...

    def test_same_members_wrong_order(self):  # -> None:
        ...
    def test_order_has_extra_members(self):  # -> None:
        ...
    def test_order_has_extra_members_with_aliases(self):  # -> None:
        ...
    def test_enum_has_extra_members(self):  # -> None:
        ...
    def test_enum_has_extra_members_with_aliases(self):  # -> None:
        ...

class OldTestFlag(unittest.TestCase):
    """Tests of the Flags."""
    class Perm(Flag): ...

    class Open(Flag):
        RO = ...
        WO = ...
        RW = ...
        AC = ...
        CE = ...

    class Color(Flag):
        BLACK = ...
        RED = ...
        ROJO = ...
        GREEN = ...
        BLUE = ...
        PURPLE = ...
        WHITE = ...
        BLANCO = ...

    def test_or(self):  # -> None:
        ...
    def test_and(self):  # -> None:
        ...
    def test_xor(self):  # -> None:
        ...
    def test_invert(self):  # -> None:
        ...
    def test_bool(self):  # -> None:
        ...
    def test_boundary(self):  # -> None:
        class Iron(Flag, boundary=STRICT): ...
        class Water(Flag, boundary=CONFORM): ...
        class Space(Flag, boundary=EJECT): ...
        class Bizarre(Flag, boundary=KEEP): ...

    def test_iter(self):  # -> None:
        ...
    def test_programatic_function_string(self):  # -> None:
        ...
    def test_programatic_function_string_with_start(self):  # -> None:
        ...
    def test_programatic_function_string_list(self):  # -> None:
        ...
    def test_programatic_function_iterable(self):  # -> None:
        ...
    def test_programatic_function_from_dict(self):  # -> None:
        ...
    def test_pickle(self):  # -> None:
        ...
    def test_contains_tf(self):  # -> None:
        ...
    def test_member_contains(self):  # -> None:
        ...
    def test_member_iter(self):  # -> None:
        ...
    def test_member_length(self):  # -> None:
        ...
    def test_number_reset_and_order_cleanup(self):  # -> None:
        class Confused(Flag): ...

    def test_aliases(self):  # -> None:
        ...
    def test_auto_number(self):  # -> None:
        class Color(Flag): ...

    def test_auto_number_garbage(self):  # -> None:
        ...
    def test_duplicate_auto(self):  # -> None:
        class Dupes(Enum): ...

    def test_multiple_mixin(self):  # -> None:
        class AllMixin: ...
        class StrMixin: ...
        class Color(AllMixin, Flag): ...
        class Color(AllMixin, StrMixin, Flag): ...
        class Color(StrMixin, AllMixin, Flag): ...

    def test_init_subclass(self):  # -> None:
        class MyEnum(Flag): ...
        class TheirEnum(MyEnum): ...
        class WhoseEnum(TheirEnum): ...
        class NoEnum(WhoseEnum): ...
        class OurEnum(MyEnum): ...
        class WhereEnum(OurEnum): ...
        class NeverEnum(WhereEnum): ...

class OldTestIntFlag(unittest.TestCase):
    """Tests of the IntFlags."""
    class Perm(IntFlag):
        R = ...
        W = ...
        X = ...

    class Open(IntFlag):
        RO = ...
        WO = ...
        RW = ...
        AC = ...
        CE = ...

    class Color(IntFlag):
        BLACK = ...
        RED = ...
        ROJO = ...
        GREEN = ...
        BLUE = ...
        PURPLE = ...
        WHITE = ...
        BLANCO = ...

    class Skip(IntFlag):
        FIRST = ...
        SECOND = ...
        EIGHTH = ...

    def test_type(self):  # -> None:
        ...
    def test_global_repr_keep(self):  # -> None:
        ...
    def test_global_repr_conform1(self):  # -> None:
        ...
    def test_global_enum_str(self):  # -> None:
        ...
    def test_format(self):  # -> None:
        class NewPerm(IntFlag): ...

    def test_or(self):  # -> None:
        ...
    def test_and(self):  # -> None:
        ...
    def test_xor(self):  # -> None:
        ...
    def test_invert(self):  # -> None:
        ...
    def test_boundary(self):  # -> None:
        class Simple(IntFlag, boundary=KEEP): ...
        class Iron(IntFlag, boundary=STRICT): ...
        class Water(IntFlag, boundary=CONFORM): ...
        class Space(IntFlag, boundary=EJECT): ...
        class Bizarre(IntFlag, boundary=KEEP): ...

    def test_iter(self):  # -> None:
        ...
    def test_programatic_function_string(self):  # -> None:
        ...
    def test_programatic_function_string_with_start(self):  # -> None:
        ...
    def test_programatic_function_string_list(self):  # -> None:
        ...
    def test_programatic_function_iterable(self):  # -> None:
        ...
    def test_programatic_function_from_dict(self):  # -> None:
        ...
    def test_programatic_function_from_empty_list(self):  # -> None:
        ...
    def test_programatic_function_from_empty_tuple(self):  # -> None:
        ...
    def test_contains_tf(self):  # -> None:
        ...
    def test_member_contains(self):  # -> None:
        ...
    def test_member_iter(self):  # -> None:
        ...
    def test_member_length(self):  # -> None:
        ...
    def test_aliases(self):  # -> None:
        ...
    def test_bool(self):  # -> None:
        ...
    def test_multiple_mixin(self):  # -> None:
        class AllMixin: ...
        class StrMixin: ...
        class Color(AllMixin, IntFlag): ...
        class Color(AllMixin, StrMixin, IntFlag): ...
        class Color(StrMixin, AllMixin, IntFlag): ...

class TestEmptyAndNonLatinStrings(unittest.TestCase):
    def test_empty_string(self):  # -> None:
        ...
    def test_non_latin_character_string(self):  # -> None:
        ...
    def test_non_latin_number_string(self):  # -> None:
        ...

class TestUnique(unittest.TestCase):
    def test_unique_clean(self):  # -> None:
        @unique
        class Clean(Enum): ...

        @unique
        class Cleaner(IntEnum): ...

    def test_unique_dirty(self):  # -> None:
        ...
    def test_unique_with_name(self):  # -> None:
        @verify(UNIQUE)
        class Silly(Enum): ...

        @verify(UNIQUE)
        class Sillier(IntEnum): ...

class TestVerify(unittest.TestCase):
    def test_continuous(self):  # -> None:
        @verify(CONTINUOUS)
        class Auto(Enum): ...

        @verify(CONTINUOUS)
        class Manual(Enum): ...

    def test_composite(self):  # -> None:
        class Bizarre(Flag): ...
        class Bizarre(IntFlag): ...

    def test_unique_clean(self):  # -> None:
        @verify(UNIQUE)
        class Clean(Enum): ...

        @verify(UNIQUE)
        class Cleaner(IntEnum): ...

    def test_unique_dirty(self):  # -> None:
        ...
    def test_unique_with_name(self):  # -> None:
        @verify(UNIQUE)
        class Silly(Enum): ...

        @verify(UNIQUE)
        class Sillier(IntEnum): ...

    def test_negative_alias(self):  # -> None:
        @verify(NAMED_FLAGS)
        class Color(Flag): ...

class TestInternals(unittest.TestCase):
    sunder_names = ...
    dunder_names = ...
    private_names = ...
    private_and_sunder_names = ...
    random_names = ...
    def test_sunder(self):  # -> None:
        ...
    def test_dunder(self):  # -> None:
        ...
    def test_is_private(self):  # -> None:
        ...
    def test_auto_number(self):  # -> None:
        class Color(Enum): ...

    def test_auto_name(self):  # -> None:
        class Color(Enum): ...

    def test_auto_name_inherit(self):  # -> None:
        class AutoNameEnum(Enum): ...
        class Color(AutoNameEnum): ...

    @unittest.skipIf(python_version >= (3, 13), "mixed types with auto() no longer supported")
    def test_auto_garbage_ok(self):  # -> None:
        ...
    @unittest.skipIf(python_version >= (3, 13), "mixed types with auto() no longer supported")
    def test_auto_garbage_corrected_ok(self):  # -> None:
        ...
    @unittest.skipIf(python_version < (3, 13), "mixed types with auto() will raise in 3.13")
    def test_auto_garbage_fail(self):  # -> None:
        ...
    @unittest.skipIf(python_version < (3, 13), "mixed types with auto() will raise in 3.13")
    def test_auto_garbage_corrected_fail(self):  # -> None:
        ...
    def test_auto_order(self):  # -> None:
        ...
    def test_auto_order_wierd(self):  # -> None:
        class Color(Enum): ...

    @unittest.skipIf(python_version < (3, 13), "auto() will return highest value + 1 in 3.13")
    def test_auto_with_aliases(self):  # -> None:
        class Color(Enum): ...

    def test_duplicate_auto(self):  # -> None:
        class Dupes(Enum): ...

    def test_multiple_auto_on_line(self):  # -> None:
        class Huh(Enum): ...
        class Hah(Enum): ...
        class Huh(Enum): ...

class TestEnumTypeSubclassing(unittest.TestCase): ...

expected_help_output_with_docs = ...
expected_help_output_without_docs = ...

class TestStdLib(unittest.TestCase):
    maxDiff = ...
    class Color(Enum):
        CYAN = ...
        MAGENTA = ...
        YELLOW = ...

    def test_pydoc(self):  # -> None:
        ...
    def test_inspect_getmembers(self):  # -> None:
        ...
    def test_inspect_classify_class_attrs(self):  # -> None:
        ...
    def test_inspect_signatures(self):  # -> None:
        ...

class MiscTestCase(unittest.TestCase):
    def test_doc_1(self):  # -> None:
        class Single(Enum): ...

    def test_doc_2(self):  # -> None:
        class Double(Enum): ...

    def test_doc_1(self):  # -> None:
        class Triple(Enum): ...

    def test_doc_1(self):  # -> None:
        class Quadruple(Enum): ...

CONVERT_TEST_NAME_D = ...
CONVERT_TEST_NAME_C = ...
CONVERT_TEST_NAME_B = ...
CONVERT_TEST_NAME_A = ...
CONVERT_TEST_NAME_E = ...
CONVERT_TEST_NAME_F = ...
CONVERT_STRING_TEST_NAME_D = ...
CONVERT_STRING_TEST_NAME_C = ...
CONVERT_STRING_TEST_NAME_B = ...
CONVERT_STRING_TEST_NAME_A = ...
CONVERT_STRING_TEST_NAME_E = ...
CONVERT_STRING_TEST_NAME_F = ...
CONVERT_STR_TEST_2 = ...
CONVERT_STR_TEST_1 = ...
UNCOMPARABLE_A = ...
UNCOMPARABLE_C = ...
UNCOMPARABLE_B = ...
COMPLEX_C = ...
COMPLEX_A = ...
COMPLEX_B = ...

class TestConvert(unittest.TestCase):
    def tearDown(self):  # -> None:
        ...
    def test_convert_value_lookup_priority(self):  # -> None:
        ...
    def test_convert_int(self):  # -> None:
        ...
    def test_convert_uncomparable(self):  # -> None:
        ...
    def test_convert_complex(self):  # -> None:
        ...
    def test_convert_str(self):  # -> None:
        ...
    def test_convert_raise(self):  # -> None:
        ...
    def test_convert_repr_and_str(self):  # -> None:
        ...

def enum_dir(cls):  # -> list[Any] | list[str | Any]:
    ...
def member_dir(member):  # -> list[str]:
    ...

if __name__ == "__main__": ...
